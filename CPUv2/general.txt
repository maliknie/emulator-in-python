EMULATING A CPU IN PYTHON

Assembly language:
    Core instructions and syntax:
        32 bit:
             jmp #imd: | 00000000 | padding with zeros (4 bits) | padding with zeros (4 bits) | immediate value (16 bits) | Description: imd -> pc
             jeq #imd: | 00000001 | padding with zeros (4 bits) | padding with zeros (4 bits) | immediate value (16 bits) | Description: if zero flag = 1, imd -> pc
             jne #imd: | 00000010 | padding with zeros (4 bits) | padding with zeros (4 bits) | immediate value (16 bits) | Description: if zero flag != 1, imd -> pc
             inc [mem]: | 00000011 | padding with zeros (4 bits) | padding with zeros (4 bits) | memory address (16 bits) | Description: [mem] += 1
             dec [mem]: | 00000100 | padding with zeros (4 bits) | padding with zeros (4 bits) | memory address (16 bits) | Description: [mem] -= 1
             load #imd, reg : | 00000101 | reg1 (4 bits) | padding with zeros (4 bits) | immediate value (16 bits) | Description: imd -> reg1
             load [mem], reg: | 00000110 | reg1 (4 bits) | padding with zeros (4 bits) | memory address (16 bits) | Description: [mem] -> reg1
             store reg, [mem]: | 00000111 | reg1 (4 bits) | padding with zeros (4 bits) | memory address (16 bits) | Description: reg1 -> [mem] 
        16 bit + 16 bit padding:
             jmp reg: | 00001000 | reg1 (4 bits) | padding with zeros (4 bits) | padding with zeros (16 bits) | Description: reg1 -> pc
             jeq reg: | 00001001 | reg1 (4 bits) | padding with zeros (4 bits) | padding with zeros (16 bits) | Description: if zero flag = 1, reg1 -> pc
             jne reg: | 00001010 | reg1 (4 bits) | padding with zeros (4 bits) | padding with zeros (16 bits) | Description: if zero flag != 1, reg1 -> pc
             store reg1, reg2: | 00001011 | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 -> [reg1]
             move reg1, reg2: | 00001100 | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 -> reg1
             add reg1, reg2: | 00001101 | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 + reg1 -> reg1
             sub reg1, reg2: | 00001110 | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 - reg1 -> reg1
             mult reg1, reg2: | 00001111 | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 * reg1 -> high 16 bits in reg1, low 16 bits in reg2
             div reg1, reg2: | 00010000 | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 / reg1 -> result in reg1, mod in reg2
             inc reg: | 00010001 | reg1 (4 bits) | padding with zeros (4 bits) | padding with zeros (16 bits) | Description: reg1 += 1
             dec reg: | 00010010 | reg1 (4 bits) | padding with zeros (4 bits) | padding with zeros (16 bits) | Description: reg1 -= 1
             and reg1, reg2: | 00010011 | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 & reg1 -> reg1
             or reg1, reg2: | 00010100 | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 | reg1 -> reg1
             xor reg1, reg2: | 00010101 | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 ^ reg1 -> reg1
             not reg 1: | 00010110 | reg1 (4 bits) | padding with zeros (4 bits) | padding with zeros (16 bits) | Description: ~reg1 -> reg1
             rol reg1, #imd: | 00010111 | reg1 (4 bits) | imd (4 bits) | padding with zeros (16 bits) | Description: reg1 << imd -> reg1
             ror reg1, #imd: | 00011000 | reg1 (4 bits) | imd (4 bits) | padding with zeros (16 bits) | Description: reg1 >> imd -> reg1
             cmp reg1, reg2: | 00011001 | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 - reg1 (only changes flags)

        Special
            NOP: NOP - does nothing
            HLT: HLT -Stops execution of program
            INT: INT <INTERRUPT_NUMBER> - Triggers a software interrupt, transferring control to the interrupt handler specified by <INTERRUPT_NUMBER>.
            RET: RET - Returns from a subroutine by popping the return address off the stack and jumping to that address.
            Comment: ; This is a comment (specified by the semicolon)
    Operand types:
        Immediate value (e.g. #3)
        Registers (e.g. r1)
        Memory Adress (e.g. [10])
    Adressing modes:
        Immediate Adressing: Operand is constant and specified in the instruction itself
        Register adressing: Operand is in the specified register
        Direct  adressing: Operand is at the memory adress specified in the instruction itself
        Indirect adressing: Operand is at the memory adress contained in the register specified in the instruction 
    Directives:
        DB: Define Byte - Allocates and optionally initializes a byte of data.
        .data: Defines a sections for data declarations
        .start: Marks the beginning of the section containing executable instructions
        Comment: Semicolon (;) marks the beginning of a comment (until the end of the line)

Number representation:
    Negative numbers:
        Two's complement
    Rational numbers:
        fixed-point numbers


Computer Components:
    CPU
        CU 
        ALU
        Registers
    Memory (RAM)


        

