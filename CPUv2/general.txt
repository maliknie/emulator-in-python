EMULATING A CPU IN PYTHON

Assembly language:
    Core instructions and syntax:
        32 bit:
            jmp #imd: | opcode (8 bits) | padding with zeros (4 bits) | padding with zeros (4 bits) | immediate value (16 bits) | Description: imd -> pc
            jeq #imd: | opcode (8 bits) | padding with zeros (4 bits) | padding with zeros (4 bits) | immediate value (16 bits) | Description: if zero flag = 1, imd -> pc
            jne #imd: | opcode (8 bits) | padding with zeros (4 bits) | padding with zeros (4 bits) | immediate value (16 bits) | Description: if zero flag != 1, imd -> pc
            inc [mem]: | opcode (8 bits) | padding with zeros (4 bits) | padding with zeros (4 bits) | memory address (16 bits) | Description: [mem] += 1
            dec [mem]: | opcode (8 bits) | padding with zeros (4 bits) | padding with zeros (4 bits) | memory address (16 bits) | Description: [mem] -= 1
            load #imd, reg : | opcode (8 bits) | reg1 (4 bits) | padding with zeros (4 bits) | immediate value (16 bits) | Description: imd -> reg1
            load [mem], reg: | opcode (8 bits) | reg1 (4 bits) | padding with zeros (4 bits) | memory address (16 bits) | Description: [mem] -> reg1
            store reg, [mem]: | opcode (8 bits) | reg1 (4 bits) | padding with zeros (4 bits) | memory address (16 bits) | Description: reg1 -> [mem] 
        16 bit:
            jmp reg: | opcode (8 bits) | reg1 (4 bits) | padding with zeros (4 bits) | padding with zeros (16 bits) | Description: reg1 -> pc
            jeq reg: | opcode (8 bits) | reg1 (4 bits) | padding with zeros (4 bits) | padding with zeros (16 bits) | Description: if zero flag = 1, reg1 -> pc
            jne reg: | opcode (8 bits) | reg1 (4 bits) | padding with zeros (4 bits) | padding with zeros (16 bits) | Description: if zero flag != 1, reg1 -> pc
            store reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 -> [reg1]
            move reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 -> reg1
            add reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 + reg1 -> reg1
            sub reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 - reg1 -> reg1
            mult reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 * reg1 -> high 16 bits in reg1, low 16 bits in reg2
            div reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 / reg1 -> result in reg1, mod in reg2
            inc reg: | opcode (8 bits) | reg1 (4 bits) | padding with zeros (4 bits) | padding with zeros (16 bits) | Description: reg1 += 1
            dec reg: | opcode (8 bits) | reg1 (4 bits) | padding with zeros (4 bits) | padding with zeros (16 bits) | Description: reg1 -= 1
            and reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 & reg1 -> reg1
            or reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 | reg1 -> reg1
            xor reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 ^ reg1 -> reg1
            not reg 1: | opcode (8 bits) | reg1 (4 bits) | padding with zeros (4 bits) | padding with zeros (16 bits) | Description: ~reg1 -> reg1
            rol reg1, #imd: | opcode (8 bits) | reg1 (4 bits) | imd (4 bits) | padding with zeros (16 bits) | Description: reg1 << imd -> reg1
            ror reg1, #imd: | opcode (8 bits) | reg1 (4 bits) | imd (4 bits) | padding with zeros (16 bits) | Description: reg1 >> imd -> reg1
            cmp reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 - reg1 (only changes flags)

        Special
            NOP: NOP - does nothing
            HLT: HLT -Stops execution of program
            INT: INT <INTERRUPT_NUMBER> - Triggers a software interrupt, transferring control to the interrupt handler specified by <INTERRUPT_NUMBER>.
            RET: RET - Returns from a subroutine by popping the return address off the stack and jumping to that address.
            Comment: ; This is a comment (specified by the semicolon)
    Operand types:
        Immediate value (e.g. #3)
        Registers (e.g. r1)
        Memory Adress (e.g. [10])
    Adressing modes:
        Immediate Adressing: Operand is constant and specified in the instruction itself
        Register adressing: Operand is in the specified register
        Direct  adressing: Operand is at the memory adress specified in the instruction itself
        Indirect adressing: Operand is at the memory adress contained in the register specified in the instruction 
    Directives:
        DB: Define Byte - Allocates and optionally initializes a byte of data.
        .data: Defines a sections for data declarations
        .start: Marks the beginning of the section containing executable instructions
        Comment: Semicolon (;) marks the beginning of a comment (until the end of the line)

Number representation:
    Negative numbers:
        Two's complement
    Rational numbers:
        fixed-point numbers


Computer Components:
    CPU
        CU 
        ALU
        Registers
    Memory (RAM)


        

