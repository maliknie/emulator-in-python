EMULATING A CPU IN PYTHON

Assembly language:
    Core instructions and syntax:
        32 bit:
            00000000 jmp #imd: | opcode (8 bits) | padding with zeros (4 bits) | padding with zeros (4 bits) | immediate value (16 bits) | Description: imd -> pc
            00000001 jeq #imd: | opcode (8 bits) | padding with zeros (4 bits) | padding with zeros (4 bits) | immediate value (16 bits) | Description: if zero flag = 1, imd -> pc
            00000010 jne #imd: | opcode (8 bits) | padding with zeros (4 bits) | padding with zeros (4 bits) | immediate value (16 bits) | Description: if zero flag != 1, imd -> pc
            00000011 inc [mem]: | opcode (8 bits) | padding with zeros (4 bits) | padding with zeros (4 bits) | memory address (16 bits) | Description: [mem] += 1
            00000100 dec [mem]: | opcode (8 bits) | padding with zeros (4 bits) | padding with zeros (4 bits) | memory address (16 bits) | Description: [mem] -= 1
            00000101 load #imd, reg : | opcode (8 bits) | reg1 (4 bits) | padding with zeros (4 bits) | immediate value (16 bits) | Description: imd -> reg1
            00000110 load [mem], reg: | opcode (8 bits) | reg1 (4 bits) | padding with zeros (4 bits) | memory address (16 bits) | Description: [mem] -> reg1
            00000111 store reg, [mem]: | opcode (8 bits) | reg1 (4 bits) | padding with zeros (4 bits) | memory address (16 bits) | Description: reg1 -> [mem] 
        16 bit:
            00001000 jmp reg: | opcode (8 bits) | reg1 (4 bits) | padding with zeros (4 bits) | padding with zeros (16 bits) | Description: reg1 -> pc
            00001001 jeq reg: | opcode (8 bits) | reg1 (4 bits) | padding with zeros (4 bits) | padding with zeros (16 bits) | Description: if zero flag = 1, reg1 -> pc
            00001010 jne reg: | opcode (8 bits) | reg1 (4 bits) | padding with zeros (4 bits) | padding with zeros (16 bits) | Description: if zero flag != 1, reg1 -> pc
            00001011 store reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 -> [reg1]
            00001100 move reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 -> reg1
            00001101 add reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 + reg1 -> reg1
            00001110 sub reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 - reg1 -> reg1
            00001111 mult reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 * reg1 -> high 16 bits in reg1, low 16 bits in reg2
            00010000 div reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 / reg1 -> result in reg1, mod in reg2
            00010001 inc reg: | opcode (8 bits) | reg1 (4 bits) | padding with zeros (4 bits) | padding with zeros (16 bits) | Description: reg1 += 1
            00010010 dec reg: | opcode (8 bits) | reg1 (4 bits) | padding with zeros (4 bits) | padding with zeros (16 bits) | Description: reg1 -= 1
            00010011 and reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 & reg1 -> reg1
            00010100 or reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 | reg1 -> reg1
            00010101 xor reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 ^ reg1 -> reg1
            00010110 not reg 1: | opcode (8 bits) | reg1 (4 bits) | padding with zeros (4 bits) | padding with zeros (16 bits) | Description: ~reg1 -> reg1
            00010111 rol reg1, #imd: | opcode (8 bits) | reg1 (4 bits) | imd (4 bits) | padding with zeros (16 bits) | Description: reg1 << imd -> reg1
            00011000 ror reg1, #imd: | opcode (8 bits) | reg1 (4 bits) | imd (4 bits) | padding with zeros (16 bits) | Description: reg1 >> imd -> reg1
            00011001 cmp reg1, reg2: | opcode (8 bits) | reg1 (4 bits) | reg2 (4 bits) | padding with zeros (16 bits) | Description: reg2 - reg1 (only changes flags)

        Special
            NOP: NOP - does nothing
            HLT: HLT -Stops execution of program
            INT: INT <INTERRUPT_NUMBER> - Triggers a software interrupt, transferring control to the interrupt handler specified by <INTERRUPT_NUMBER>.
            RET: RET - Returns from a subroutine by popping the return address off the stack and jumping to that address.
            Comment: ; This is a comment (specified by the semicolon)
    Operand types:
        Immediate value (e.g. #3)
        Registers (e.g. r1)
        Memory Adress (e.g. [10])
    Adressing modes:
        Immediate Adressing: Operand is constant and specified in the instruction itself
        Register adressing: Operand is in the specified register
        Direct  adressing: Operand is at the memory adress specified in the instruction itself
        Indirect adressing: Operand is at the memory adress contained in the register specified in the instruction 
    Directives:
        DB: Define Byte - Allocates and optionally initializes a byte of data.
        .data: Defines a sections for data declarations
        .start: Marks the beginning of the section containing executable instructions
        Comment: Semicolon (;) marks the beginning of a comment (until the end of the line)

Number representation:
    Negative numbers:
        Two's complement
    Rational numbers:
        fixed-point numbers


Computer Components:
    CPU
        CU 
        ALU
        Registers
    Memory (RAM)


        

